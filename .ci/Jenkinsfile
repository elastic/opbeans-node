#!/usr/bin/env groovy
@Library('apm@current') _

// XXX Adapted from opbeansPipeline() in apm-pipeline-library.git

pipeline {
  agent { label 'linux && immutable' }
  environment {
    BASE_DIR = 'src/github.com/elastic'
    NOTIFY_TO = credentials('notify-to')
    PIPELINE_LOG_LEVEL = 'INFO'
    PATH = "${env.PATH}:${env.WORKSPACE}/bin"
    HOME = "${env.WORKSPACE}"
  }
  options {
    timeout(time: 10, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20', daysToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    disableResume()
    durabilityHint('PERFORMANCE_OPTIMIZED')
    rateLimitBuilds(throttle: [count: 60, durationName: 'hour', userBoost: true])
    quietPeriod(10)
    disableConcurrentBuilds(abortPrevious: isPR())
  }
  triggers {
    // Only main branch will run on a timer basis
    cron(env.BRANCH_NAME == 'main' ? '@weekly' : '')
  }
  stages {
    // If there is an available newer APM agent version, e.g. "1.2.3", then
    // update to it and tag this repo with that version, e.g. "v1.2.3".
    stage('Update APM Agent Dep') {
      // XXX
      // when {
      //   branch 'main'
      // }
      steps {
        withGithubNotify(context: 'Update Agent Dep') {
          deleteDir()
          gitCheckout(basedir: BASE_DIR)
          dir(BASE_DIR){
            sh(script: 'printenv')
            script {
              AVAIL_AGENT_UPDATE_VER = sh(
                  script: '.ci/avail-agent-update-ver.sh',
                  returnStdout: true
              ).trim()
              if (AVAIL_AGENT_UPDATE_VER) {
                echo "Available agent version update: '${AVAIL_AGENT_UPDATE_VER}'"
                // sh(script: ".ci/bump-version.sh ${AVAIL_AGENT_UPDATE_VER}")
                // gitPush()
                // gitCreateTag(tag: "v${AVAIL_AGENT_UPDATE_VER}")
              } else {
                echo "This repo is already using the latest available APM agent version."
              }
            }
          }
        }
      }
    }
  }
  post {
    always {
      notifyBuildResult()
    }
  }
}

// def runBuildITs(String repo, String stagingDockerImage) {
//   build(job: env.ITS_PIPELINE, propagate: waitIfNotPR(), wait: waitIfNotPR(),
//         parameters: [string(name: 'INTEGRATION_TEST', value: 'Opbeans'),
//                      string(name: 'BUILD_OPTS', value: "${generateBuildOpts(repo, stagingDockerImage)}"),
//                      string(name: 'GITHUB_CHECK_NAME', value: env.GITHUB_CHECK_ITS_NAME),
//                      string(name: 'GITHUB_CHECK_REPO', value: repo),
//                      string(name: 'GITHUB_CHECK_SHA1', value: env.GIT_BASE_COMMIT)])
//   githubNotify(context: "${env.GITHUB_CHECK_ITS_NAME}", description: "${env.GITHUB_CHECK_ITS_NAME} ...", status: 'PENDING', targetUrl: "${env.JENKINS_URL}search/?q=${env.ITS_PIPELINE.replaceAll('/','+')}")
// }

// def generateBuildOpts(String repo, String stagingDockerImage) {
//   switch(repo) {
//     case 'opbeans-go':
//       opts = "--with-opbeans-go --opbeans-go-branch ${env.GIT_BASE_COMMIT} --opbeans-go-repo ${getForkedRepoOrElasticRepo(repo)}"
//       break;
//     case 'opbeans-java':
//       opts = "--with-opbeans-java --opbeans-java-image ${stagingDockerImage} --opbeans-java-version ${env.GIT_BASE_COMMIT}"
//       break;
//    default:
//       opts = ''
//     break;
//   }
//   return opts.toString()
// }

// def waitIfNotPR() {
//   return !isPR()
// }

// def getForkedRepoOrElasticRepo(String repo) {
//   // See https://issues.jenkins-ci.org/browse/JENKINS-58450
//   if (env.CHANGE_FORK?.contains('/')) {
//     return env.CHANGE_FORK
//   } else {
//     return "${env.CHANGE_FORK?.trim() ?: 'elastic' }/${repo}".toString()
//   }
// }

